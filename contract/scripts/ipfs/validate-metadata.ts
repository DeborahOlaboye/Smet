import fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// ERC-721 and ERC-1155 metadata standards\nconst REQUIRED_FIELDS = ['name', 'description', 'image'];\nconst OPTIONAL_FIELDS = ['external_url', 'attributes', 'background_color'];\n\nfunction validateMetadata(metadata, tokenId, type) {\n  const errors = [];\n  const warnings = [];\n  \n  // Check required fields\n  for (const field of REQUIRED_FIELDS) {\n    if (!metadata[field]) {\n      errors.push(`Missing required field: ${field}`);\n    } else if (typeof metadata[field] !== 'string') {\n      errors.push(`Field '${field}' must be a string`);\n    }\n  }\n  \n  // Validate name\n  if (metadata.name && metadata.name.length > 100) {\n    warnings.push('Name is longer than 100 characters');\n  }\n  \n  // Validate description\n  if (metadata.description && metadata.description.length > 1000) {\n    warnings.push('Description is longer than 1000 characters');\n  }\n  \n  // Validate image URL\n  if (metadata.image) {\n    if (!metadata.image.startsWith('ipfs://') && !metadata.image.startsWith('https://')) {\n      warnings.push('Image URL should use IPFS or HTTPS protocol');\n    }\n  }\n  \n  // Validate attributes\n  if (metadata.attributes) {\n    if (!Array.isArray(metadata.attributes)) {\n      errors.push('Attributes must be an array');\n    } else {\n      metadata.attributes.forEach((attr, index) => {\n        if (!attr.trait_type || !attr.value) {\n          errors.push(`Attribute ${index} missing trait_type or value`);\n        }\n      });\n    }\n  }\n  \n  // Validate external_url\n  if (metadata.external_url && !metadata.external_url.startsWith('https://')) {\n    warnings.push('External URL should use HTTPS protocol');\n  }\n  \n  return { errors, warnings };\n}\n\nasync function validateAllMetadata() {\n  try {\n    console.log('ðŸ” Validating NFT metadata for ERC standards compliance...');\n    \n    const metadataDir = path.join(__dirname, '../metadata');\n    const heroesDir = path.join(metadataDir, 'heroes');\n    const lootDir = path.join(metadataDir, 'loot');\n    \n    const results = {\n      heroes: {},\n      loot: {},\n      summary: {\n        totalFiles: 0,\n        validFiles: 0,\n        filesWithErrors: 0,\n        filesWithWarnings: 0\n      }\n    };\n    \n    // Validate hero metadata\n    console.log('\\nðŸ“‹ Validating hero metadata...');\n    const heroFiles = fs.readdirSync(heroesDir);\n    \n    for (const file of heroFiles) {\n      if (file.endsWith('.json')) {\n        const tokenId = file.replace('.json', '');\n        const filePath = path.join(heroesDir, file);\n        const metadata = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n        \n        const validation = validateMetadata(metadata, tokenId, 'hero');\n        results.heroes[tokenId] = {\n          file,\n          valid: validation.errors.length === 0,\n          errors: validation.errors,\n          warnings: validation.warnings\n        };\n        \n        results.summary.totalFiles++;\n        if (validation.errors.length === 0) {\n          results.summary.validFiles++;\n          console.log(`âœ… Hero #${tokenId}: Valid`);\n        } else {\n          results.summary.filesWithErrors++;\n          console.log(`âŒ Hero #${tokenId}: ${validation.errors.length} errors`);\n        }\n        \n        if (validation.warnings.length > 0) {\n          results.summary.filesWithWarnings++;\n          console.log(`âš ï¸  Hero #${tokenId}: ${validation.warnings.length} warnings`);\n        }\n      }\n    }\n    \n    // Validate loot metadata\n    console.log('\\nðŸ“‹ Validating loot metadata...');\n    const lootFiles = fs.readdirSync(lootDir);\n    \n    for (const file of lootFiles) {\n      if (file.endsWith('.json')) {\n        const tokenId = file.replace('.json', '');\n        const filePath = path.join(lootDir, file);\n        const metadata = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n        \n        const validation = validateMetadata(metadata, tokenId, 'loot');\n        results.loot[tokenId] = {\n          file,\n          valid: validation.errors.length === 0,\n          errors: validation.errors,\n          warnings: validation.warnings\n        };\n        \n        results.summary.totalFiles++;\n        if (validation.errors.length === 0) {\n          results.summary.validFiles++;\n          console.log(`âœ… Loot #${tokenId}: Valid`);\n        } else {\n          results.summary.filesWithErrors++;\n          console.log(`âŒ Loot #${tokenId}: ${validation.errors.length} errors`);\n        }\n        \n        if (validation.warnings.length > 0) {\n          results.summary.filesWithWarnings++;\n          console.log(`âš ï¸  Loot #${tokenId}: ${validation.warnings.length} warnings`);\n        }\n      }\n    }\n    \n    // Save validation results\n    const resultsPath = path.join(__dirname, '../metadata-validation-results.json');\n    fs.writeFileSync(resultsPath, JSON.stringify(results, null, 2));\n    \n    // Print summary\n    console.log('\\nðŸ“Š Validation Summary:');\n    console.log(`Total files: ${results.summary.totalFiles}`);\n    console.log(`Valid files: ${results.summary.validFiles}`);\n    console.log(`Files with errors: ${results.summary.filesWithErrors}`);\n    console.log(`Files with warnings: ${results.summary.filesWithWarnings}`);\n    \n    if (results.summary.filesWithErrors === 0) {\n      console.log('\\nðŸŽ‰ All metadata files are valid!');\n    } else {\n      console.log('\\nâš ï¸  Some metadata files have errors. Please fix them before deployment.');\n    }\n    \n    console.log(`\\nðŸ“„ Detailed results saved to: ${resultsPath}`);\n    \n    return results;\n    \n  } catch (error) {\n    console.error('âŒ Error validating metadata:', error);\n    throw error;\n  }\n}\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  validateAllMetadata()\n    .then(() => process.exit(0))\n    .catch(() => process.exit(1));\n}\n\nexport { validateAllMetadata };